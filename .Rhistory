),
column(4,
strong("star"),
tags$div(id="test_6", style="width:100%;height:500px;"),
deliverChart(div_id = "test_6")
)
)
)
server <- function(input, output) {
# Call functions from ECharts2Shiny to render charts
# Radar Chart
output$test_1 <- renderWordcloud("test_1", data =sample_data_for_wordcloud,
grid_size = 1, sizeRange = c(5, 15), rotationRange = c(-90, 90))
output$test_2 <- renderWordcloud("test_2", data =sample_data_for_wordcloud, shape = "diamond",
grid_size = 1, sizeRange = c(5, 15), rotationRange = c(-90, 90))
output$test_3 <- renderWordcloud("test_3", data =sample_data_for_wordcloud, shape = "triangle",
grid_size = 1, sizeRange = c(5, 15), rotationRange = c(-90, 90))
output$test_4 <- renderWordcloud("test_4", data =sample_data_for_wordcloud, shape = "pentagon",
grid_size = 1, sizeRange = c(5, 15), rotationRange = c(-90, 90))
output$test_5 <- renderWordcloud("test_5", data =sample_data_for_wordcloud, shape = "triangle-forward",
grid_size = 1, sizeRange = c(5, 15), rotationRange = c(-90, 90))
output$test_6 <- renderWordcloud("test_6", data =sample_data_for_wordcloud, shape = "star",
grid_size = 1, sizeRange = c(5, 15), rotationRange = c(-90, 90))
}
shinyApp(ui, server)
library(shiny)
library(DT)
library(plotly)
library(wordcloud2)
library(tm)
library(crosstalk)
#Data (it will be the preprocessing of Colette)
# Read the text file from internet
filePath <- "http://www.sthda.com/sthda/RDoc/example-files/martin-luther-king-i-have-a-dream-speech.txt"
text <- readLines(filePath)
# Load the data as a corpus
docs <- Corpus(VectorSource(text))
inspect(docs)
toSpace <- content_transformer(function (x , pattern ) gsub(pattern, " ", x))
docs <- tm_map(docs, toSpace, "/")
docs <- tm_map(docs, toSpace, "@")
docs <- tm_map(docs, toSpace, "\\|")
# Convert the text to lower case
docs <- tm_map(docs, content_transformer(tolower))
# Remove numbers
docs <- tm_map(docs, removeNumbers)
# Remove english common stopwords
docs <- tm_map(docs, removeWords, stopwords("english"))
# Remove your own stop word
# specify your stopwords as a character vector
docs <- tm_map(docs, removeWords, c("blabla1", "blabla2"))
# Remove punctuations
docs <- tm_map(docs, removePunctuation)
# Eliminate extra white spaces
docs <- tm_map(docs, stripWhitespace)
# Text stemming
# docs <- tm_map(docs, stemDocument)
#Creating the data frame that will be used by the code
dtm <- TermDocumentMatrix(docs)
m <- as.matrix(dtm)
v <- sort(rowSums(m),decreasing=TRUE)
r <- abs(rnorm(length(v)))
w <- names(v)
#Changing the data structure in order that the id is a number and not a word, if not it doesn't work
names(v) <- seq(1, length(v))
#Implementing rownames in order to access them later. It will be useful to make the key
wr <- seq(1, length(v))
#Creating the dataframe
d <- data.frame(rowname = wr, word = w, freq=v, random = r)
head(d, 10)
#Find the maximum frequency and the number of words to implement the sliderinputs
m <- max(d$freq)
n <- NROW(d)
# use the key aesthetic/argument to help uniquely identify selected observations
key <- row.names(d)
#Shiny App
#UI and layout. It implements the front-end
#Creating a navbar page with different tabs, which are created by tabPanel
ui <- navbarPage("NLP App",
tabPanel("Plot overview",
sidebarLayout(
#This implements the sidebar that offers the choice of the metric
sidebarPanel(
selectInput(inputId = 'choice', label = 'Choose a metric',
choice = c('Frequency', 'Random')),
fileInput("file1", "Choose PDF File",
multiple = FALSE)
),
#The main panel is composed of a plotly graph and a data table
mainPanel(
plotlyOutput("plot_overview"),
DT::dataTableOutput("table_overview"))
)
),
tabPanel("Plot filtering",
#Slider button to filter the data
sliderInput(inputId = "slide_value_freq", label = "Filter the frequency", min = 1, max = m, value = c(1,m), step = 1, dragRange = TRUE),
sliderInput(inputId = "slide_value_word", label = "Choose the maximum number of words", min = 1, max = n, value = n, step = 1),
wordcloud2Output("wordcloud"),
#This HTML script implements the click option for the wordcloud
tags$script(HTML(
"$(document).on('click', '#canvas', function() {",
'word = document.getElementById("wcSpan").innerHTML;',
"Shiny.onInputChange('selected_word', word);",
"});"
)),
verbatimTextOutput("test")
),
tabPanel("Word in context"
)
)
#Server function that implements the back-end
server <- function(input, output, session){
#Shared data between the plot and the datatable of the overview and the wordcloud
d_shared <- SharedData$new(d, ~key)
#Plotting the scatterplot with plotly
output$plot_overview <- renderPlotly({
if(input$choice=='Frequency'){
#s1 matches the row selected by the user
s1 <- input$plot_rows_selected
if(!length(s1)){
plot_ly(d_shared, x = ~rowname, y = ~freq, key = ~key, type = 'scatter', mode='line',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Frequency according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Frequency'), titlefont = 'arial', showlegend = FALSE)%>% highlight("plotly_selected", color = I('green'))
}
else if(length(s1)){
plot_ly(d, x = ~rowname, y = ~freq, key = ~key, type = 'scatter', mode='line',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Frequency according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Frequency'), titlefont = 'arial', showlegend = FALSE)
}
}
else if(input$choice=='Random'){
#s2 is the same as s1 but for the other graph
s2 <- input$plot_rows_selected
if(!length(s2)){
plot_ly(d_shared, x = ~rowname, y = ~random, key = ~key, type = 'scatter', mode='markers',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Random according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Random'), titlefont = 'arial', showlegend = FALSE)%>% highlight("plotly_selected", color = I('green'))
}
else if(length(s2)){
plot_ly(d, x = ~rowname, y = ~random, key = ~key, type = 'scatter', mode='markers',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Random according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Random'), titlefont = 'arial', showlegend = FALSE)      }
}
})
#Plotting the Data Table
output$table_overview <- DT::renderDataTable({
dsel <- d[d_shared$selection(),]
dt <-DT::datatable(d,options = list(columnDefs = list(list(className = 'dt-center', targets = "_all")),pageLength = 5, lengthMenu = c(5, 10, 15, 20)),class = 'display')
if (NROW(dsel) == 0) {
dt
} else {
DT::formatStyle(dt, "rowname", target = "row",
color = DT::styleEqual(dsel$rowname, rep("white", length(dsel$rowname))), backgroundColor = DT::styleEqual(dsel$rowname, rep("black", length(dsel$rowname))))
}
})
#Choosing the data which is shared with the plot
d_real_shared <- reactive({d[d_shared$selection(),]})
#Choosing the data to give to the wordcloud, depending on which data is taken from plotly
filter_d <- reactive({
#Changing the data in order to match what the wordcloud takes as an input
d_prime_reac <- reactive({data.frame(d_real_shared()$word, d_real_shared()$freq)})
head(subset(d_prime_reac(), d_real_shared...freq <= (input$slide_value_freq[2]) & d_real_shared...freq >=
(input$slide_value_freq[1])),
input$slide_value_word)
})
#Creating the wordcloud and making it reactive to change in the input values
output$wordcloud  <- renderWordcloud2(wordcloud2(data = filter_d(),
shape = 'star', size = 0.8, shuffle =FALSE))
output$test <- renderPrint({
input$selected_word
})
}
shinyApp(ui, server)
library(shiny)
library(DT)
library(plotly)
library(wordcloud2)
library(tm)
library(crosstalk)
#Data (it will be the preprocessing of Colette)
# Read the text file from internet
filePath <- "http://www.sthda.com/sthda/RDoc/example-files/martin-luther-king-i-have-a-dream-speech.txt"
text <- readLines(filePath)
# Load the data as a corpus
docs <- Corpus(VectorSource(text))
inspect(docs)
toSpace <- content_transformer(function (x , pattern ) gsub(pattern, " ", x))
docs <- tm_map(docs, toSpace, "/")
docs <- tm_map(docs, toSpace, "@")
docs <- tm_map(docs, toSpace, "\\|")
# Convert the text to lower case
docs <- tm_map(docs, content_transformer(tolower))
# Remove numbers
docs <- tm_map(docs, removeNumbers)
# Remove english common stopwords
docs <- tm_map(docs, removeWords, stopwords("english"))
# Remove your own stop word
# specify your stopwords as a character vector
docs <- tm_map(docs, removeWords, c("blabla1", "blabla2"))
# Remove punctuations
docs <- tm_map(docs, removePunctuation)
# Eliminate extra white spaces
docs <- tm_map(docs, stripWhitespace)
# Text stemming
# docs <- tm_map(docs, stemDocument)
#Creating the data frame that will be used by the code
dtm <- TermDocumentMatrix(docs)
m <- as.matrix(dtm)
v <- sort(rowSums(m),decreasing=TRUE)
r <- abs(rnorm(length(v)))
w <- names(v)
#Changing the data structure in order that the id is a number and not a word, if not it doesn't work
names(v) <- seq(1, length(v))
#Implementing rownames in order to access them later. It will be useful to make the key
wr <- seq(1, length(v))
#Creating the dataframe
d <- data.frame(rowname = wr, word = w, freq=v, random = r)
head(d, 10)
#Find the maximum frequency and the number of words to implement the sliderinputs
m <- max(d$freq)
n <- NROW(d)
# use the key aesthetic/argument to help uniquely identify selected observations
key <- row.names(d)
#Shiny App
#UI and layout. It implements the front-end
#Creating a navbar page with different tabs, which are created by tabPanel
ui <- navbarPage("NLP App",
tabPanel("Plot overview",
sidebarLayout(
#This implements the sidebar that offers the choice of the metric
sidebarPanel(
selectInput(inputId = 'choice', label = 'Choose a metric',
choice = c('Frequency', 'Random')),
fileInput("file1", "Choose PDF File",
multiple = FALSE)
),
#The main panel is composed of a plotly graph and a data table
mainPanel(
plotlyOutput("plot_overview"),
DT::dataTableOutput("table_overview"))
)
),
tabPanel("Plot filtering",
#Slider button to filter the data
sliderInput(inputId = "slide_value_freq", label = "Filter the frequency", min = 1, max = m, value = c(1,m), step = 1, dragRange = TRUE),
sliderInput(inputId = "slide_value_word", label = "Choose the maximum number of words", min = 1, max = n, value = n, step = 1),
wordcloud2Output("wordcloud"),
#This HTML script implements the click option for the wordcloud
tags$script(HTML(
"$(document).on('click', '#canvas', function() {",
'word = document.getElementById("wcSpan").innerHTML;',
"Shiny.onInputChange('selected_word', word);",
"});"
)),
verbatimTextOutput("test")
),
tabPanel("Word in context"
)
)
#Server function that implements the back-end
server <- function(input, output, session){
#Shared data between the plot and the datatable of the overview and the wordcloud
d_shared <- SharedData$new(d, ~key)
#Plotting the scatterplot with plotly
output$plot_overview <- renderPlotly({
if(input$choice=='Frequency'){
#s1 matches the row selected by the user
s1 <- input$plot_rows_selected
if(!length(s1)){
plot_ly(d_shared, x = ~rowname, y = ~freq, key = ~key, type = 'scatter', mode='line',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Frequency according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Frequency'), titlefont = 'arial', showlegend = FALSE)%>% highlight("plotly_selected", color = I('green'))
}
else if(length(s1)){
plot_ly(d, x = ~rowname, y = ~freq, key = ~key, type = 'scatter', mode='line',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Frequency according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Frequency'), titlefont = 'arial', showlegend = FALSE)
}
}
else if(input$choice=='Random'){
#s2 is the same as s1 but for the other graph
s2 <- input$plot_rows_selected
if(!length(s2)){
plot_ly(d_shared, x = ~rowname, y = ~random, key = ~key, type = 'scatter', mode='markers',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Random according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Random'), titlefont = 'arial', showlegend = FALSE)%>% highlight("plotly_selected", color = I('green'))
}
else if(length(s2)){
plot_ly(d, x = ~rowname, y = ~random, key = ~key, type = 'scatter', mode='markers',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Random according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Random'), titlefont = 'arial', showlegend = FALSE)      }
}
})
#Plotting the Data Table
output$table_overview <- DT::renderDataTable({
dsel <- d[d_shared$selection(),]
dt <-DT::datatable(d,options = list(columnDefs = list(list(className = 'dt-center', targets = "_all")),pageLength = 5, lengthMenu = c(5, 10, 15, 20)),class = 'display')
if (NROW(dsel) == 0) {
dt
} else {
DT::formatStyle(dt, "rowname", target = "row",
color = DT::styleEqual(dsel$rowname, rep("white", length(dsel$rowname))), backgroundColor = DT::styleEqual(dsel$rowname, rep("black", length(dsel$rowname))))
}
})
#Choosing the data which is shared with the plot
d_real_shared <- reactive({d[d_shared$selection(),]})
#Choosing the data to give to the wordcloud, depending on which data is taken from plotly
filter_d <- reactive({
#Changing the data in order to match what the wordcloud takes as an input
d_prime_reac <- reactive({data.frame(d_real_shared()$word, d_real_shared()$freq)})
head(subset(d_prime_reac(), d_real_shared...freq <= (input$slide_value_freq[2]) & d_real_shared...freq >=
(input$slide_value_freq[1])),
input$slide_value_word)
})
#Creating the wordcloud and making it reactive to change in the input values
output$wordcloud  <- renderWordcloud2(wordcloud2(data = filter_d(),
shape = 'star', size = 0.8, shuffle =FALSE))
output$test <- renderPrint({
input$selected_word
})
}
shinyApp(ui, server)
R.version
runApp()
install.packages(shiny)
install.packages(DT)
install.packages(plotly)
install.packages(wordcloud2)
install.packages(tm)
install.packages(crosstalk)
install.packages(“shiny”)
install.packages(“DT”)
install.packages(“plotly”)
install.packages(“wordcloud2”)
install.packages(“tm”)
install.packages(“crosstalk”)
install.packages(‘shiny’)
install.packages(‘DT’)
install.packages(‘plotly’)
install.packages(‘wordcloud2’)
install.packages(‘tm’)
install.packages(‘crosstalk’)
install.package("shiny")
install.package("DT")
install.package("plotly")
install.package("wordcloud2")
install.package("tm")
install.package("crosstalk")
install.packages("shiny")
install.packages("shiny")
install.packages("DT")
install.packages("plotly")
install.packages("wordcloud2")
install.packages("tm")
install.packages("crosstalk")
install.packages("shiny")
install.packages("shiny")
install.packages("DT")
install.packages("plotly")
install.packages("wordcloud2")
install.packages("tm")
install.packages("crosstalk")
library(shiny)
library(DT)
library(plotly)
library(wordcloud2)
library(tm)
library(crosstalk)
#Data (it will be the preprocessing of Colette)
# Read the text file from internet
filePath <- "http://www.sthda.com/sthda/RDoc/example-files/martin-luther-king-i-have-a-dream-speech.txt"
text <- readLines(filePath)
# Load the data as a corpus
docs <- Corpus(VectorSource(text))
inspect(docs)
toSpace <- content_transformer(function (x , pattern ) gsub(pattern, " ", x))
docs <- tm_map(docs, toSpace, "/")
docs <- tm_map(docs, toSpace, "@")
docs <- tm_map(docs, toSpace, "\\|")
# Convert the text to lower case
docs <- tm_map(docs, content_transformer(tolower))
# Remove numbers
docs <- tm_map(docs, removeNumbers)
# Remove english common stopwords
docs <- tm_map(docs, removeWords, stopwords("english"))
# Remove your own stop word
# specify your stopwords as a character vector
docs <- tm_map(docs, removeWords, c("blabla1", "blabla2"))
# Remove punctuations
docs <- tm_map(docs, removePunctuation)
# Eliminate extra white spaces
docs <- tm_map(docs, stripWhitespace)
# Text stemming
# docs <- tm_map(docs, stemDocument)
#Creating the data frame that will be used by the code
dtm <- TermDocumentMatrix(docs)
m <- as.matrix(dtm)
v <- sort(rowSums(m),decreasing=TRUE)
r <- abs(rnorm(length(v)))
w <- names(v)
#Changing the data structure in order that the id is a number and not a word, if not it doesn't work
names(v) <- seq(1, length(v))
#Implementing rownames in order to access them later. It will be useful to make the key
wr <- seq(1, length(v))
#Creating the dataframe
d <- data.frame(rowname = wr, word = w, freq=v, random = r)
head(d, 10)
#Find the maximum frequency and the number of words to implement the sliderinputs
m <- max(d$freq)
n <- NROW(d)
# use the key aesthetic/argument to help uniquely identify selected observations
key <- row.names(d)
#Shiny App
#UI and layout. It implements the front-end
#Creating a navbar page with different tabs, which are created by tabPanel
ui <- navbarPage("NLP App",
tabPanel("Plot overview",
sidebarLayout(
#This implements the sidebar that offers the choice of the metric
sidebarPanel(
selectInput(inputId = 'choice', label = 'Choose a metric',
choice = c('Frequency', 'Random')),
fileInput("file1", "Choose PDF File",
multiple = FALSE)
),
#The main panel is composed of a plotly graph and a data table
mainPanel(
plotlyOutput("plot_overview"),
DT::dataTableOutput("table_overview"))
)
),
tabPanel("Plot filtering",
#Slider button to filter the data
sliderInput(inputId = "slide_value_freq", label = "Filter the frequency", min = 1, max = m, value = c(1,m), step = 1, dragRange = TRUE),
sliderInput(inputId = "slide_value_word", label = "Choose the maximum number of words", min = 1, max = n, value = n, step = 1),
wordcloud2Output("wordcloud"),
#This HTML script implements the click option for the wordcloud
tags$script(HTML(
"$(document).on('click', '#canvas', function() {",
'word = document.getElementById("wcSpan").innerHTML;',
"Shiny.onInputChange('selected_word', word);",
"});"
)),
verbatimTextOutput("test")
),
tabPanel("Word in context"
)
)
#Server function that implements the back-end
server <- function(input, output, session){
#Shared data between the plot and the datatable of the overview and the wordcloud
d_shared <- SharedData$new(d, ~key)
#Plotting the scatterplot with plotly
output$plot_overview <- renderPlotly({
if(input$choice=='Frequency'){
#s1 matches the row selected by the user
s1 <- input$plot_rows_selected
if(!length(s1)){
plot_ly(d_shared, x = ~rowname, y = ~freq, key = ~key, type = 'scatter', mode='line',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Frequency according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Frequency'), titlefont = 'arial', showlegend = FALSE)%>% highlight("plotly_selected", color = I('green'))
}
else if(length(s1)){
plot_ly(d, x = ~rowname, y = ~freq, key = ~key, type = 'scatter', mode='line',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Frequency according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Frequency'), titlefont = 'arial', showlegend = FALSE)
}
}
else if(input$choice=='Random'){
#s2 is the same as s1 but for the other graph
s2 <- input$plot_rows_selected
if(!length(s2)){
plot_ly(d_shared, x = ~rowname, y = ~random, key = ~key, type = 'scatter', mode='markers',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Random according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Random'), titlefont = 'arial', showlegend = FALSE)%>% highlight("plotly_selected", color = I('green'))
}
else if(length(s2)){
plot_ly(d, x = ~rowname, y = ~random, key = ~key, type = 'scatter', mode='markers',  marker = list(color = 'blue', opacity=2))%>%layout(title = 'Random according to the word', xaxis = list(title ='Word'), yaxis =list(title ='Random'), titlefont = 'arial', showlegend = FALSE)      }
}
})
#Plotting the Data Table
output$table_overview <- DT::renderDataTable({
dsel <- d[d_shared$selection(),]
dt <-DT::datatable(d,options = list(columnDefs = list(list(className = 'dt-center', targets = "_all")),pageLength = 5, lengthMenu = c(5, 10, 15, 20)),class = 'display')
if (NROW(dsel) == 0) {
dt
} else {
DT::formatStyle(dt, "rowname", target = "row",
color = DT::styleEqual(dsel$rowname, rep("white", length(dsel$rowname))), backgroundColor = DT::styleEqual(dsel$rowname, rep("black", length(dsel$rowname))))
}
})
#Choosing the data which is shared with the plot
d_real_shared <- reactive({d[d_shared$selection(),]})
#Choosing the data to give to the wordcloud, depending on which data is taken from plotly
filter_d <- reactive({
#Changing the data in order to match what the wordcloud takes as an input
d_prime_reac <- reactive({data.frame(d_real_shared()$word, d_real_shared()$freq)})
head(subset(d_prime_reac(), d_real_shared...freq <= (input$slide_value_freq[2]) & d_real_shared...freq >=
(input$slide_value_freq[1])),
input$slide_value_word)
})
#Creating the wordcloud and making it reactive to change in the input values
output$wordcloud  <- renderWordcloud2(wordcloud2(data = filter_d(),
shape = 'star', size = 0.8, shuffle =FALSE))
output$test <- renderPrint({
input$selected_word
})
}
shinyApp(ui, server)
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("NLP")
install.packages("NLP")
install.packages("NLP")
install.packages("NLP")
runApp
runApp()
library("shiny")
runApp(C:/Users/Projet/Desktop/Internship/Application)
runApp(Users/Projet/Desktop/Internship/Application)
runApp(C:\Users/Projet/Desktop/Internship/Application)
runApp("C:/Users/Projet/Desktop/Internship/Application")
runApp("C:\Users\Projet\Desktop\Internship\Application")
runApp("C:/Users/Projet/Desktop/Internship/Application")
setwd("~/")
setwd(dir = 'C:/Users/Projet/Internship_Visua_Combine')
runApp(launch.browser = TRUE)
library('Shiny')
libPaths
Shiny.libPaths
DT.libPaths
DT.libPaths()
DT.libPaths(new)
